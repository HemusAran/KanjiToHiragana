/* 	File:		Dictionary.h  	Contains:	Interfaces to Dictionary Manager   	Version:	Technology: Language Analysis Architecture 1.1.1				Release: To be used with Universal Interfaces 3.2  	Copyright:	1998 by Apple Computer, Inc., all rights reserved  	Bugs?:		Please include the the file and version information (from above) with 				the problem description.  Developers belonging to one of the Apple 				developer programs can submit bug reports to:  					daruma@apple.com */#include <Carbon/Carbon.h>#ifndef __DICTIONARY__#define __DICTIONARY__#ifndef __TYPES__#include <Types.h>#endif#ifndef __FILES__#include <Files.h>#endif#ifndef __APPLEEVENTS__#include <AppleEvents.h>#endif#ifndef __AEREGISTRY__#include <AERegistry.h>#endif#ifndef __ASREGISTRY__#include <ASRegistry.h>#endif#ifndef __CODEFRAGMENTS__#include <CodeFragments.h>#endif#ifdef __cplusplusextern "C" {#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import on#endif#if PRAGMA_ALIGN_SUPPORTED#pragma options align=power/* the following contents can only be used by compilers that support PowerPC struct alignment *//*============================================================================================= System 8.5 Dictionary Manager=============================================================================================*//*	Dictionary information*/enum{	kDictionaryFileType				= 'dict',	kDCMDictionaryHeaderSignature	= 'dict',	kDCMDictionaryHeaderVersion		= 2};enum{	kDCMAnyFieldTag					= typeWildCard,	kDCMAnyFieldType				= typeWildCard};/*	Contents of a Field Info Record (an AERecord)*/enum{	keyDCMFieldTag					= 'ftag',			/* typeEnumeration */	keyDCMFieldType					= 'ftyp',			/* typeEnumeration */	keyDCMMaxRecordSize				= 'mrsz',			/* typeMagnitude */	keyDCMFieldAttributes			= 'fatr',	keyDCMFieldDefaultData			= 'fdef',	keyDCMFieldName					= 'fnam',			/* typeChar */	keyDCMFieldFindMethods			= 'ffnd'			/* typeAEList of typeDCMFindMethod (or one typeDCMFindMethod, or null descriptor, or missing keyword) */};/*	Special types for fields of a Field Info Record*/enum{	typeDCMFieldAttributes			= 'fatr',	typeDCMFindMethod				= 'fmth'};/*	Field attributes*/enum{	kDCMIndexedFieldMask			= 0x00000001,	kDCMRequiredFieldMask			= 0x00000002,	kDCMIdentifyFieldMask			= 0x00000004,	kDCMFixedSizeFieldMask			= 0x00000008,	kDCMHiddenFieldMask				= 0x80000000};typedef OptionBits DCMFieldAttributes;/*	Standard dictionary properties*/enum{	pDCMAccessMethod				= 'amtd',					/* data type: typeChar ReadOnly */	pDCMPermission					= 'perm',					/* data type: typeUInt16 */	pDCMListing						= 'list',					/* data type: typeUInt16 */	pDCMMaintenance					= 'mtnc',					/* data type: typeUInt16 */	pDCMLocale						= 'locl',					/* data type: typeUInt32.  Optional; default = kLocaleIdentifierWildCard */	pDCMClass						= pClass,					/* data type: typeUInt16 */	pDCMCopyright					= 'info'					/* data type: typeChar */};/*	pDCMPermission property constants*/enum{	kDCMReadOnlyDictionary			= 0,	kDCMReadWriteDictionary			= 1};/*	pDCMListing property constants*/enum{	kDCMAllowListing				= 0,	kDCMProhibitListing				= 1};/*	pDCMClass property constants*/enum{	kDCMUserDictionaryClass			= 0,	kDCMSpecificDictionaryClass		= 1,	kDCMBasicDictionaryClass		= 2};/*	Standard search method*/enum{	kDCMFindMethodExactMatch		= kAEEquals,	kDCMFindMethodBeginningMatch	= kAEBeginsWith,	kDCMFindMethodContainsMatch		= kAEContains,	kDCMFindMethodEndingMatch		= kAEEndsWith,	kDCMFindMethodForwardTrie		= 'ftri',				/* used for morphological analysis*/	kDCMFindMethodBackwardTrie		= 'btri'				/* used for morphological analysis*/};typedef OSType DCMFindMethod;typedef UInt32 DCMUniqueID;typedef struct OpaqueDCMObjectID* DCMObjectID;typedef DCMObjectID DCMAccessMethodID;typedef DCMObjectID DCMDictionaryID;#define kDCMInvalidObjectID ((DCMObjectID) kInvalidID)typedef struct OpaqueDCMObjectRef* DCMObjectRef;typedef DCMObjectRef DCMDictionaryRef;typedef DCMObjectRef DCMDictionaryStreamRef;#define kDCMInvalidObjectRef ((DCMObjectRef) kInvalidID)typedef struct OpaqueDCMObjectIterator* DCMObjectIterator;typedef DCMObjectIterator DCMAccessMethodIterator;typedef DCMObjectIterator DCMDictionaryIterator;typedef struct OpaqueDCMFoundRecordIterator* DCMFoundRecordIterator;/*	Field specification declarations*/typedef DescType DCMFieldTag;typedef DescType DCMFieldType;/*	Dictionary header information*/struct DCMDictionaryHeader {	FourCharCode 					headerSignature;	UInt32 							headerVersion;	ByteCount 						headerSize;	Str63 							accessMethod;};typedef struct DCMDictionaryHeader DCMDictionaryHeader;/*	Error values*/enum{	dcmParamErr					= -7100,						/* bad parameter*/	dcmNotDictionaryErr			= -7101,						/* not dictionary*/	dcmBadDictionaryErr			= -7102,						/* invalid dictionary*/	dcmPermissionErr			= -7103,						/* invalid permission*/	dcmDictionaryNotOpenErr		= -7104,						/* dictionary not opened*/	dcmDictionaryBusyErr		= -7105,						/* dictionary is busy*/	dcmBadDictionaryTypeErr		= -7106,						/* bad dictionary type*/	dcmBlockFullErr				= -7107,						/* dictionary block full*/	dcmNoRecordErr				= -7108,						/* no such record*/	dcmDupRecordErr				= -7109,						/* same record already exist*/	dcmNecessaryFieldErr		= -7110,						/* lack required/identify field*/	dcmBadFieldInfoErr			= -7111,						/* incomplete information*/	dcmBadFieldTypeErr			= -7112,						/* no such field type supported*/	dcmNoFieldErr				= -7113,						/* no such field exist*/	dcmDupFieldErr				= -7114,						/* field already exist*/	dcmBadKeyErr				= -7115,						/* bad key information*/	dcmTooManyKeyErr			= -7116,						/* too many key field*/	dcmBadDataSizeErr			= -7117,						/* too big data size*/	dcmBadFindMethodErr			= -7118,						/* no such find method supported*/	dcmBadPropertyErr			= -7119,						/* no such property exist*/	dcmEndOfStreamErr			= -7120,						/* reaches end of stream*/	dcmProtectedErr				= -7121,						/* need keyword to use dictionary*/	dcmNoAccessMethodErr		= -7122,						/* no such AccessMethod*/	dcmDupAccessMethodErr		= -7123,						/* AccessMethod already exist*/	dcmBadFeatureErr			= -7124,						/* invalid AccessMethod feature*/	dcmAccessMethodBusyErr		= -7125,						/* AccessMethod is busy*/	dcmIterationCompleteErr		= -7126,						/* no more item in iterator*/	dcmBufferOverflowErr		= -7127,						/* data is larger than buffer size*/	dcmChangesCommittedErr		= -7128							/* changes cannot be backed out (Access Method probably does not support transactions)*/};/*	Callback routines*/typedef pascal Boolean (*DCMProgressFilterProcPtr)(Boolean determinateProcess, UInt16 percentageComplete, UInt32 callbackUD);#if GENERATINGCFMtypedef UniversalProcPtr			DCMProgressFilterUPP;#elsetypedef DCMProgressFilterProcPtr	DCMProgressFilterUPP;#endifenum {	uppDCMProgressFilterProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Boolean)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(UInt16)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(UInt32)))};#if GENERATINGCFM#define NewDCMProgressFilterProc(userRoutine)		\		(DCMProgressFilterUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppDCMProgressFilterProcInfo, GetCurrentArchitecture())#else#define NewDCMProgressFilterProc(userRoutine)		\		((DCMProgressFilterUPP) (userRoutine))#endif#if GENERATINGCFM#define CallDCMProgressFilterProc(userRoutine, determinateProcess, percentageComplete, callbackUD)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppLAAnalysisFilterProcInfo, (determinateProcess), (percentageComplete), (callbackUD))#else#define CallDCMProgressFilterProc(userRoutine, determinateProcess, percentageComplete, callbackUD)		\		(*(userRoutine))((determinateProcess), (percentageComplete), (callbackUD))#endif/*	Library version*/extern pascal UInt32DCMLibraryVersion( void );/*	Create/delete dictionary*/extern pascal OSStatusDCMNewDictionary(		DCMAccessMethodID		accessMethodID,		const FSSpec			*newDictionaryFile, 		ScriptCode				scriptTag,		const AEDesc*			listOfFieldInfoRecords, 		Boolean					invisible, 		ItemCount				recordCapacity, 		DCMDictionaryID			*newDictionary);extern pascal OSStatusDCMDeriveNewDictionary(		DCMDictionaryID			srcDictionary,		const FSSpec			*newDictionaryFile, 		ScriptCode				scriptTag,		Boolean					invisible,		ItemCount				recordCapacity,		DCMDictionaryID			*newDictionary);extern pascal OSStatusDCMDeleteDictionary(		DCMDictionaryID			dictionaryID);/*	Register dictionary*/extern pascal OSStatusDCMRegisterDictionaryFile(		const FSSpec			*dictionaryFile,		DCMDictionaryID			*dictionaryID);extern pascal OSStatusDCMUnregisterDictionary(		DCMDictionaryID			dictionaryID);/*	Open dictionary*/extern pascal OSStatusDCMOpenDictionary(		DCMDictionaryID			dictionaryID,		ByteCount				protectKeySize,		ConstLogicalAddress		protectKey,		DCMDictionaryRef		*dictionaryRef);extern pascal OSStatusDCMCloseDictionary(		DCMDictionaryRef		dictionaryRef);/*	Change access privilege*/extern pascal OSStatusDCMGetDictionaryWriteAccess(		DCMDictionaryRef		dictionaryRef,		Duration				timeOutDuration);extern pascal OSStatusDCMReleaseDictionaryWriteAccess(		DCMDictionaryRef		dictionaryRef,		Boolean					commitTransaction);/*	Find records*/extern pascal OSStatusDCMFindRecords(		DCMDictionaryRef		dictionaryRef,		DCMFieldTag				keyFieldTag,		ByteCount				keySize,		ConstLogicalAddress		keyData,		DCMFindMethod			findMethod,		ItemCount				preFetchedDataNum,		DCMFieldTag				preFetchedData[],		ItemCount				skipCount,		ItemCount				maxRecordCount,		DCMFoundRecordIterator	*recordIterator);extern pascal ItemCountDCMCountRecordIterator(		DCMFoundRecordIterator	recordIterator);extern pascal OSStatusDCMIterateFoundRecord(		DCMFoundRecordIterator	recordIterator,		ByteCount				maxKeySize,		ByteCount				*actualKeySize,		LogicalAddress			keyData,		DCMUniqueID				*uniqueID,		AEDesc					*dataList);extern pascal OSStatusDCMDisposeRecordIterator(		DCMFoundRecordIterator	recordIterator);/*	Dump dictionary*/extern pascal OSStatusDCMCountRecord(		DCMDictionaryID			dictionaryID,		ItemCount				*count);extern pascal OSStatusDCMGetRecordSequenceNumber(		DCMDictionaryRef		dictionaryRef,		DCMFieldTag				keyFieldTag,		ByteCount				keySize,		ConstLogicalAddress		keyData,		DCMUniqueID				uniqueID,		ItemCount				*sequenceNum);extern pascal OSStatusDCMGetNthRecord(		DCMDictionaryRef		dictionaryRef,		DCMFieldTag				keyFieldTag,		ItemCount				serialNum,		ByteCount				maxKeySize,		ByteCount				*keySize,		LogicalAddress			keyData,		DCMUniqueID				*uniqueID);extern pascal OSStatusDCMGetNextRecord(		DCMDictionaryRef		dictionaryRef,		DCMFieldTag				keyFieldTag,		ByteCount				keySize,		ConstLogicalAddress		keyData,		DCMUniqueID				uniqueID,		ByteCount				maxKeySize,		ByteCount				*nextKeySize,		LogicalAddress			nextKeyData,		DCMUniqueID				*nextUniqueID);extern pascal OSStatusDCMGetPrevRecord(		DCMDictionaryRef		dictionaryRef,		DCMFieldTag				keyFieldTag,		ByteCount				keySize,		ConstLogicalAddress		keyData,		DCMUniqueID				uniqueID,		ByteCount				maxKeySize,		ByteCount				*prevKeySize,		LogicalAddress			prevKeyData,		DCMUniqueID				*prevUniqueID);/*	Get field data*/extern pascal OSStatusDCMGetFieldData(		DCMDictionaryRef		dictionaryRef,		DCMFieldTag				keyFieldTag,		ByteCount				keySize,		ConstLogicalAddress		keyData,		DCMUniqueID				uniqueID,		ItemCount				numOfData,		const DCMFieldTag		dataTag[],		AEDesc					*dataList);extern pascal OSStatusDCMSetFieldData(		DCMDictionaryRef		dictionaryRef,		DCMFieldTag				keyFieldTag,		ByteCount				keySize,		ConstLogicalAddress		keyData,		DCMUniqueID				uniqueID,		const AEDesc			*dataList);/*	Add record*/extern pascal OSStatusDCMAddRecord(		DCMDictionaryRef		dictionaryRef,		DCMFieldTag				keyFieldTag,		ByteCount				keySize,		ConstLogicalAddress		keyData,		Boolean					checkOnly,		const AEDesc			*dataList,		DCMUniqueID				*newUniqueID);extern pascal OSStatusDCMDeleteRecord(		DCMDictionaryRef		dictionaryRef,		DCMFieldTag				keyFieldTag,		ByteCount				keySize,		ConstLogicalAddress		keyData,		DCMUniqueID				uniqueID);/*	Reorganize/compact dictionary*/extern pascal OSStatusDCMReorganizeDictionary(		DCMDictionaryID			dictionaryID,		ItemCount				extraCapacity,		DCMProgressFilterUPP	progressProc,		UInt32					userData);extern pascal OSStatusDCMCompactDictionary(		DCMDictionaryID			dictionaryID,		DCMProgressFilterUPP	progressProc,		UInt32					userData);/*	DictionaryID utilities*/extern pascal OSStatusDCMGetFileFromDictionaryID(		DCMDictionaryID			dictionaryID,		FSSpec					*fileRef);extern pascal OSStatusDCMGetDictionaryIDFromFile(		const FSSpec			*fileRef,		DCMDictionaryID			*dictionaryID);extern pascal DCMDictionaryIDDCMGetDictionaryIDFromRef(		DCMDictionaryRef		dictionaryRef);/*	Field information and manipulation*/// fieldTag can be typeWildCard for allextern pascal OSStatusDCMGetDictionaryFieldInfo(		DCMDictionaryID			dictionaryID,		DCMFieldTag				fieldTag,		AEDesc*					fieldInfoRecord);/*	Dictionary property*/extern pascal OSStatusDCMGetDictionaryProperty(		DCMDictionaryID			dictionaryID,		DCMFieldTag				propertyTag,		ByteCount				maxPropertySize,		ByteCount				*actualSize,		LogicalAddress			propertyValue);extern pascal OSStatusDCMSetDictionaryProperty(		DCMDictionaryID			dictionaryID,		DCMFieldTag				propertyTag,		ByteCount				propertySize,		ConstLogicalAddress		propertyValue);extern pascal OSStatusDCMGetDictionaryPropertyList(		DCMDictionaryID			dictionaryID,		ItemCount				maxPropertyNum,		ItemCount				*numProperties,		DCMFieldTag				propertyTag[]);/*	Seaarch dictionary*/extern pascal OSStatusDCMCreateDictionaryIterator(		DCMDictionaryIterator	*dictionaryIterator);/*	Iterator Operation*/extern pascal ItemCountDCMCountObjectIterator(		DCMObjectIterator		iterator);extern pascal OSStatusDCMIterateObject(		DCMObjectIterator		iterator,		DCMObjectID				*objectID);extern pascal OSStatusDCMResetObjectIterator(		DCMObjectIterator		iterator);extern pascal OSStatusDCMDisposeObjectIterator(		DCMObjectIterator		iterator);/*	Get AccessMethod information*/extern pascal OSStatusDCMGetAccessMethodIDFromName(		ConstStr63Param			accessMethodName,		DCMAccessMethodID		*accessMethodID);/*	Field Info Record routines*/extern pascal OSStatus DCMCreateFieldInfoRecord(		DescType				fieldTag,		DescType				fieldType,		ByteCount				maxRecordSize,		DCMFieldAttributes		fieldAttributes,		AEDesc*					fieldDefaultData,		ItemCount				numberOfFindMethods,		DCMFindMethod			findMethods[],		AEDesc*					fieldInfoRecord);extern pascal OSStatus DCMGetFieldTagAndType(		const AEDesc*			fieldInfoRecord,		DCMFieldTag				*fieldTag,		DCMFieldType			*fieldType);extern pascal OSStatus DCMGetFieldMaxRecordSize(		const AEDesc*			fieldInfoRecord,		ByteCount				*maxRecordSize);extern pascal OSStatus DCMGetFieldAttributes(		const AEDesc*			fieldInfoRecord,		DCMFieldAttributes		*attributes);extern pascal OSStatus DCMGetFieldDefaultData(		const AEDesc*			fieldInfoRecord,		DescType				desiredType,		AEDesc*					fieldDefaultData);extern pascal OSStatus DCMGetFieldFindMethods(		const AEDesc*			fieldInfoRecord,		ItemCount				findMethodsArrayMaxSize,		DCMFindMethod			findMethods[],		ItemCount				*actualNumberOfFindMethods);/*	Check Dictionary Manager availability*/#ifdef __cplusplusinline pascal Boolean DCMDictionaryManagerAvailable() { return (DCMLibraryVersion != (void*)kUnresolvedCFragSymbolAddress); }#else#define DCMDictionaryManagerAvailable() 	((DCMLibraryVersion != (void*)kUnresolvedCFragSymbolAddress))#endif/*============================================================================================= System 7 Dictionary Manager=============================================================================================*/#pragma options align=reset#pragma options align=mac68k#endif /* PRAGMA_ALIGN_SUPPORTED */#if 1 /* for chages of _eDictionary.h */enum {																/* Dictionary data insertion modes */	kInsert						= 0,							/* Only insert the input entry if there is nothing in the dictionary that matches the key. */	kReplace					= 1,							/* Only replace the entries which match the key with the input entry. */	kInsertOrReplace			= 2								/* Insert the entry if there is nothing in the dictionary which matches the key, otherwise replaces the existing matched entries with the input entry. */};/* This Was InsertMode */typedef short DictionaryDataInsertMode;enum {																/* Key attribute constants */	kIsCaseSensitive			= 0x10,							/* case sensitive = 16		*/	kIsNotDiacriticalSensitive	= 0x20							/* diac not sensitive = 32	*/};enum {																/* Registered attribute type constants.	*/	kNoun						= -1,	kVerb						= -2,	kAdjective					= -3,	kAdverb						= -4};/* This Was AttributeType */typedef SInt8 DictionaryEntryAttribute;/* Dictionary information record */struct DictionaryInformation {	FSSpec 							dictionaryFSSpec;	SInt32 							numberOfRecords;	SInt32 							currentGarbageSize;	ScriptCode 						script;	SInt16 							maximumKeyLength;	SInt8 							keyAttributes;};typedef struct DictionaryInformation DictionaryInformation;struct DictionaryAttributeTable {	UInt8 							datSize;	DictionaryEntryAttribute 		datTable[1];};typedef struct DictionaryAttributeTable DictionaryAttributeTable;typedef DictionaryAttributeTable *DictionaryAttributeTablePtr;extern pascal OSErr InitializeDictionary(const FSSpec *theFsspecPtr, SInt16 maximumKeyLength, SInt8 keyAttributes, ScriptCode script) THREEWORDINLINE(0x303C, 0x0500, 0xAA53);extern pascal OSErr OpenDictionary(const FSSpec *theFsspecPtr, SInt8 accessPermission, SInt32 *dictionaryReference) THREEWORDINLINE(0x303C, 0x0501, 0xAA53);extern pascal OSErr CloseDictionary(SInt32 dictionaryReference) THREEWORDINLINE(0x303C, 0x0202, 0xAA53);extern pascal OSErr InsertRecordToDictionary(SInt32 dictionaryReference, ConstStr255Param key, Handle recordDataHandle, DictionaryDataInsertMode whichMode) THREEWORDINLINE(0x303C, 0x0703, 0xAA53);extern pascal OSErr DeleteRecordFromDictionary(SInt32 dictionaryReference, ConstStr255Param key) THREEWORDINLINE(0x303C, 0x0404, 0xAA53);extern pascal OSErr FindRecordInDictionary(SInt32 dictionaryReference, ConstStr255Param key, DictionaryAttributeTablePtr requestedAttributeTablePointer, Handle recordDataHandle) THREEWORDINLINE(0x303C, 0x0805, 0xAA53);extern pascal OSErr FindRecordByIndexInDictionary(SInt32 dictionaryReference, SInt32 recordIndex, DictionaryAttributeTablePtr requestedAttributeTablePointer, Str255 recordKey, Handle recordDataHandle) THREEWORDINLINE(0x303C, 0x0A06, 0xAA53);extern pascal OSErr GetDictionaryInformation(SInt32 dictionaryReference, DictionaryInformation *theDictionaryInformation) THREEWORDINLINE(0x303C, 0x0407, 0xAA53);extern pascal OSErr CompactDictionary(SInt32 dictionaryReference) THREEWORDINLINE(0x303C, 0x0208, 0xAA53);#endif /* for chages of _eDictionary.h */#if PRAGMA_ALIGN_SUPPORTED#pragma options align=reset#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import off#endif#ifdef __cplusplus}#endif#endif /* __DICTIONARY__ */